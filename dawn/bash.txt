‚òû BASH

‚Ä¢ COMMAND:
cat pl/tool 

‚Ä¢ OUTPUT:
# Ultroid - UserBot
# Copyright (C) 2021 TeamUltroid
#
# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >
# PLease read the GNU Affero General Public License in
# <https://www.github.com/TeamUltroid/Ultroid/blob/main/LICENSE/>.

"""
‚úò Commands Available -

‚Ä¢ {i}circle
    Reply to a audio song or gif to get video note.

‚Ä¢ {i}ls
    Get all the Files inside a Directory.

‚Ä¢ {i}bots
    Shows the number of bots in the current chat with their perma-link.

‚Ä¢ {i}hl <a link>
    Embeds the link with a whitespace as message.

‚Ä¢ {i}id
    Reply a Sticker to Get Its Id
    Reply a User to Get His Id
    Without Replying You Will Get the Chat's Id

‚Ä¢ {i}sg <reply to a user><username/id>
    Get His Name History of the replied user.

‚Ä¢ {i}tr <dest lang code> <(reply to) a message>
    Get translated message.

"""

import os
import time
from asyncio.exceptions import TimeoutError
from pathlib import Path

import cv2
from googletrans import Translator
from hachoir.metadata import extractMetadata
from hachoir.parser import createParser
from telethon.errors.rpcerrorlist import YouBlockedUserError
from telethon.tl.types import ChannelParticipantAdmin, ChannelParticipantsBots
from telethon.tl.types import DocumentAttributeVideo as video
from telethon.utils import packbotfileid

from . import 
from . import humanbytes as hb


@ultroidcmd(
    pattern="tr",
)
async def (event):
    if len(event.text) > 3:
        if not event.text[3] == " ":
            return
    input = event.text[4:6]
    txt = event.text[7:]
    xx = await eor(event, "Translating...")
    if event.replytomsgid:
        previousmessage = await event.getreplymessage()
        text = previousmessage.message
        lan = input or "en"
    elif input:
        text = txt
        lan = input or "en"
    else:
        return await eod(xx, f"{hndlr}tr LanguageCode as reply to a message", time=5)
    translator = Translator()
    try:
        tt = translator.translate(text, dest=lan)
        outputstr = f"TRANSLATED from {tt.src} to {lan}\n{tt.text}"
        await eor(xx, outputstr)
    except Exception as exc:
        await eod(xx, str(exc), time=10)


@ultroidcmd(
    pattern="id ?(.)",
)
async def (event):
    if event.replytomsgid:
        await event.getinputchat()
        rmsg = await event.getreplymessage()
        if rmsg.media:
            botapifileid = packbotfileid(rmsg.media)
            await eor(
                event,
                "Current Chat ID:  {}\nFrom User ID:  {}\nBot API File ID:  {}".format(
                    str(event.chatid),
                    str(rmsg.senderid),
                    botapifileid,
                ),
            )
        else:
            await eor(
                event,
                "Chat ID:  {}\nUser ID:  {}".format(
                    str(event.chatid),
                    str(rmsg.senderid),
                ),
            )
    elif event.patternmatch.group(1):
        ids = await getuserid(event.patternmatch.group(1))
        return await eor(
            event,
            "Chat ID:  {}\nUser ID:  {}".format(
                str(event.chatid),
                str(ids),
            ),
        )
    else:
        await eor(event, "Current Chat ID:  {}".format(str(event.chatid)))


@ultroidcmd(
    pattern="bots ?(.)",
)
async def (ult):
    await ult.edit("...")
    if ult.isprivate:
        user = await ult.getchat()
        if not user.bot:
            return await ult.edit("Seariously ?")

    mentions = "Bots in this Chat: \n"
    inputstr = ult.patternmatch.group(1)
    towritechat = await ult.getinputchat()
    chat = None
    if not inputstr:
        chat = towritechat
    else:
        mentions = f"Bots in {inputstr}: \n"
        try:
            chat = await ultroidbot.getentity(inputstr)
        except Exception as e:
            await eor(ult, str(e))
            return None
    try:
        async for x in ultroidbot.iterparticipants(
            chat,
            filter=ChannelParticipantsBots,
        ):
            if isinstance(x.participant, ChannelParticipantAdmin):
                mentions += "\n ‚öúÔ∏è [{}](tg://user?id={}) {}".format(
                    x.firstname,
                    x.id,
                    x.id,
                )
            else:
                mentions += "\n [{}](tg://user?id={}) {}".format(
                    x.firstname,
                    x.id,
                    x.id,
                )
    except Exception as e:
        mentions += " " + str(e) + "\n"
    await eor(ult, mentions)


@ultroidcmd(
    pattern="hl",
)
async def (ult):
    try:
        input = ult.text.split(" ", maxsplit=1)[1]
    except IndexError:
        return await eod(ult, "Input some link", time=5)
    await eor(ult, "[„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§„Ö§](" + input + ")", linkpreview=False)


@ultroidcmd(
    pattern="circle$",
)
async def (e):
    a = await e.getreplymessage()
    if a is None:
        return await eor(e, "Reply to a gif or audio")
    if a.document and a.document.mimetype == "audio/mpeg":
        z = await eor(e, "C Ä·¥á·¥Ä·¥õ…™…¥…¢ V…™·¥Ö·¥á·¥è N·¥è·¥õ·¥á")
        toime = time.time()
        try:
            bbbb = await a.downloadmedia(thumb=-1)
            im = cv2.imread(bbbb)
            dsize = (320, 320)
            output = cv2.resize(im, dsize, interpolation=cv2.INTERAREA)
            cv2.imwrite("img.png", output)
            thumb = "img.png"
            os.remove(bbbb)
        except TypeError:
            bbbb = "resources/extras/ultroid.jpg"
            im = cv2.imread(bbbb)
            dsize = (320, 320)
            output = cv2.resize(im, dsize, interpolation=cv2.INTERAREA)
            cv2.imwrite("img.png", output)
            thumb = "img.png"
        c = await downloader(
            "resources/downloads/" + a.file.name,
            a.media.document,
            z,
            toime,
            "D·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö…™…¥…¢...",
        )
        await z.edit("D·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö·¥á·¥Ö...\nN·¥è·¥° C·¥è…¥·¥†·¥á Ä·¥õ…™…¥…¢...")
        await bash(
            f'ffmpeg -i "{c.name}" -preset ultrafast -acodec libmp3lame -ac 2 -ab 144 -ar 44100 comp.mp3'
        )
        await bash(
            f'ffmpeg -y -i "{thumb}" -i comp.mp3 -preset ultrafast -c:a copy circle.mp4'
        )
        taime = time.time()
        foile = await uploader("circle.mp4", "circle.mp4", taime, z, "U·¥ò ü·¥è·¥Ä·¥Ö…™…¥…¢...")
        metadata = extractMetadata(createParser("circle.mp4"))
        duration = metadata.get("duration").seconds
        attributes = [video(duration=duration, w=320, h=320, roundmessage=True)]
        await e.client.sendfile(
            e.chatid,
            foile,
            thumb=thumb,
            replyto=a,
            attributes=attributes,
        )
        await z.delete()
        os.system("rm resources/downloads/")
        os.system("rm circle.mp4 comp.mp3 img.png")
    elif a.document and a.document.mimetype == "video/mp4":
        z = await eor(e, "C Ä·¥á·¥Ä·¥õ…™…¥…¢ V…™·¥Ö·¥á·¥è N·¥è·¥õ·¥á")
        c = await a.downloadmedia("resources/downloads/")
        await e.client.sendfile(
            e.chatid,
            c,
            videonote=True,
            thumb="resources/extras/ultroid.jpg",
            replyto=a,
        )
        await z.delete()
        os.remove(c)
    else:
        return await eor(e, "Reply to a gif or audio file only")


@ultroidcmd(
    pattern="ls ?(.)",
)
async def (e):
    path = Path(e.patternmatch.group(1))
    if not path:
        path = Path(".")
    else:
        if not os.path.isdir(path):
            return await eod(e, "Incorrect Directory.")
        if not os.listdir(path):
            return await eod(e, "This Directory is Empty.")
    files = path.iterdir()
    pyfiles = []
    jsons = []
    vdos = []
    audios = []
    pics = []
    others = []
    otherfiles = []
    folders = []
    text = []
    apk = []
    exe = []
    zip = []
    book = []
    for file in sorted(files):
        if os.path.isdir(file):
            folders.append("üìÇ " + str(file))
        elif str(file).endswith(".py"):
            pyfiles.append("üêç " + str(file))
        elif str(file).endswith(".json"):
            jsons.append("üîÆ " + str(file))
        elif str(file).endswith((".mkv", ".mp4", ".avi", ".gif")):
            vdos.append("üé• " + str(file))
        elif str(file).endswith((".mp3", ".ogg", ".m4a")):
            audios.append("üîä " + str(file))
        elif str(file).endswith((".jpg", ".jpeg", ".png", ".webp")):
            pics.append("üñº " + str(file))
        elif str(file).endswith((".txt", ".text", ".log")):
            text.append("üìÑ " + str(file))
        elif str(file).endswith((".apk", ".xapk")):
            apk.append("üì≤ " + str(file))
        elif str(file).endswith(".exe"):
            exe.append("‚öô " + str(file))
        elif str(file).endswith((".zip", ".rar")):
            zip.append("üóú " + str(file))
        elif str(file).endswith((".pdf", ".epub")):
            book.append("üìó " + str(file))
        elif "." in str(file)[1:]:
            others.append("üè∑ " + str(file))
        else:
            otherfiles.append("üìí " + str(file))
    omk = [
        sorted(folders),
        sorted(pyfiles),
        sorted(jsons),
        sorted(zip),
        sorted(vdos),
        sorted(pics),
        sorted(audios),
        sorted(apk),
        sorted(exe),
        sorted(book),
        sorted(text),
        sorted(others),
        sorted(otherfiles),
    ]
    text = ""
    fls, fos = 0, 0
    flc, foc = 0, 0
    for i in omk:
        emoji = i.split()[0]
        name = i.split(maxsplit=1)[1]
        nam = name.split("/")[-1]
        if os.path.isdir(name):
            size = 0
            for path, dirs, files in os.walk(name):
                for f in files:
                    fp = os.path.join(path, f)
                    size += os.path.getsize(fp)
            if hb(size):
                text += emoji + f" {nam}" + "  " + hb(size) + "\n"
                fos += size
            else:
                text += emoji + f" {nam}" + "\n"
            foc += 1
        else:
            if hb(int(os.path.getsize(name))):
                text += (
                    emoji + f" {nam}" + "  " + hb(int(os.path.getsize(name))) + "\n"
                )
                fls += int(os.path.getsize(name))
            else:
                text += emoji + f" {nam}" + "\n"
            flc += 1
    tfos, tfls, ttol = hb(fos), hb(fls), hb(fos + fls)
    if not hb(fos):
        tfos = "0 B"
    if not hb(fls):
        tfls = "0 B"
    if not hb(fos + fls):
        ttol = "0 B"
    text += f"\n\nFolders :  {foc} :   {tfos}\nFiles :       {flc} :   {tfls}\nTotal :       {flc+foc} :   {ttol}"
    await eor(e, text)


@ultroidcmd(
    pattern="sg ?(.)",
)
async def lastname(steal):
    mat = steal.patternmatch.group(1)
    if not (steal.isreply or mat):
        await eor(steal, "Use this command with reply or give Username/id...")
        return
    if mat:
        userid = await getuserid(mat)
    message = await steal.getreplymessage()
    if message:
        userid = message.sender.id
    chat = "@SangMataInfobot"
    id = f"/searchid {userid}"
    lol = await eor(steal, "Processing !...")
    try:
        async with ultroidbot.conversation(chat) as conv:
            try:
                msg = await conv.sendmessage(id)
                response = await conv.getresponse()
                respond = await conv.getresponse()
                responds = await conv.getresponse()
            except YouBlockedUserError:
                await lol.edit("Please unblock @sangmatainfobot and try again")
                return
            if (
                response.text.startswith("No records found")
                or respond.text.startswith("No records found")
                or responds.text.startswith("No records found")
            ):
                await lol.edit("No records found for this user")
                await steal.client.deletemessages(conv.chatid, [msg.id, response.id])
                return
            else:
                if response.text.startswith("üîó"):
                    await lol.edit(respond.message)
                    await lol.reply(responds.message)
                elif respond.text.startswith("üîó"):
                    await lol.edit(response.message)
                    await lol.reply(responds.message)
                else:
                    await lol.edit(respond.message)
                    await lol.reply(response.message)
            await steal.client.deletemessages(
                conv.chatid,
                [msg.id, responds.id, respond.id, response.id],
            )
    except TimeoutError:
        return await lol.edit("Error: @SangMataInfobot is not responding!.")